// ---------------------------------------------------------------------------
// This file is auto-generated.
// Do not edit this file directly.
// ---------------------------------------------------------------------------
#include "./schema.h"
// ---------------------------------------------------------------------------
namespace imlab {
namespace schema {
// ---------------------------------------------------------------------------

const std::vector<IU> DocumentTable::IUs = {
    IU("Document", "DocId", schemac::Type::Integer()),
    IU("Document", "Links.Backward", schemac::Type::Integer()),
    IU("Document", "Links.Forward", schemac::Type::Integer()),
    IU("Document", "Name.Language.Code", schemac::Type::Varchar(30)),
    IU("Document", "Name.Language.Country", schemac::Type::Varchar(30)),
    IU("Document", "Name.Url", schemac::Type::Varchar(30)),
};

std::vector<const IU*> DocumentTable::get_ius() {
    std::vector<const IU*> refs {};
    refs.reserve(IUs.size());
    for (auto& iu : IUs) {
        refs.push_back(&iu);
    }
    return refs;
}

uint64_t DocumentTable::insert(Document& record) {
    // Before we insert records with DissectRecord, we need to remember the last indices in each column.
    // They will be the starting points of the fields of the dissected record.
    DocId_Record_TIDs.push_back(DocId.get_size());
    Links_Backward_Record_TIDs.push_back(Links_Backward.get_size());
    Links_Forward_Record_TIDs.push_back(Links_Forward.get_size());
    Name_Language_Code_Record_TIDs.push_back(Name_Language_Code.get_size());
    Name_Language_Country_Record_TIDs.push_back(Name_Language_Country.get_size());
    Name_Url_Record_TIDs.push_back(Name_Url.get_size());

    DissectRecord(dynamic_cast<TableBase&>(*this), record);

    // Now the table contains one more record
    return size++;
}

// ---------------------------------------------------------------------------
}  // namespace schema
}  // namespace imlab
// ---------------------------------------------------------------------------
