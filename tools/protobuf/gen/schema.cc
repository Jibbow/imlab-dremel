// ---------------------------------------------------------------------------
// This file is auto-generated.
// Do not edit this file directly.
// ---------------------------------------------------------------------------
#include "./schema.h"
#include "imlab/dremel/shredding.h"
#include "imlab/dremel/assembling.h"
#include "imlab/dremel/record_fsm.h"
// ---------------------------------------------------------------------------
namespace imlab {
namespace schema {
// ---------------------------------------------------------------------------

const std::vector<IU> DocumentTable::IUs = {
    IU("Document", "DocId", schemac::Type::Integer()),
    IU("Document", "Links.Backward", schemac::Type::Integer()),
    IU("Document", "Links.Forward", schemac::Type::Integer()),
    IU("Document", "Name.Language.Code", schemac::Type::Varchar(30)),
    IU("Document", "Name.Language.Country", schemac::Type::Varchar(30)),
    IU("Document", "Name.Url", schemac::Type::Varchar(30)),
};

std::vector<const IU*> DocumentTable::get_ius() {
    std::vector<const IU*> refs {};
    refs.reserve(IUs.size());
    for (auto& iu : IUs) {
        refs.push_back(&iu);
    }
    return refs;
}

uint64_t DocumentTable::insert(Document& record) {
    // Before we insert records with DissectRecord, we need to remember the last indices in each column.
    // They will be the starting points of the fields of the dissected record.
    DocId_Record_TIDs.push_back(DocId.get_size());
    Links_Backward_Record_TIDs.push_back(Links_Backward.get_size());
    Links_Forward_Record_TIDs.push_back(Links_Forward.get_size());
    Name_Language_Code_Record_TIDs.push_back(Name_Language_Code.get_size());
    Name_Language_Country_Record_TIDs.push_back(Name_Language_Country.get_size());
    Name_Url_Record_TIDs.push_back(Name_Url.get_size());

    Shredder::DissectRecord(dynamic_cast<TableBase&>(*this), record);

    // Now the table contains one more record
    return size++;
}

std::vector<Document> DocumentTable::get_range(uint64_t from_tid, uint64_t to_tid, const std::vector<const FieldDescriptor*>& fields) {
    assert(from_tid >= 0 && from_tid <= to_tid && to_tid < get_size());
    RecordFSM fsm {fields};
    // TODO get readers and initialize with TID
    uint64_t DocId_index = DocId_Record_TIDs[from_tid];
    uint64_t Links_Backward_index = Links_Backward_Record_TIDs[from_tid];
    uint64_t Links_Forward_index = Links_Forward_Record_TIDs[from_tid];
    uint64_t Name_Language_Code_index = Name_Language_Code_Record_TIDs[from_tid];
    uint64_t Name_Language_Country_index = Name_Language_Country_Record_TIDs[from_tid];
    uint64_t Name_Url_index = Name_Url_Record_TIDs[from_tid];

    std::vector<Document> records {};
    for (unsigned i = from_tid; i < to_tid; i++) {
        records.push_back(Assembler<Document>::AssembleRecord(fsm, readers));
    }
    return records;
}

// ---------------------------------------------------------------------------
}  // namespace schema
}  // namespace imlab
// ---------------------------------------------------------------------------
