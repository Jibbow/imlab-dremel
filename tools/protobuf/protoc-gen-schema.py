#!/usr/bin/env python

"""
This little Python script serves as a plugin for protoc.

Will be invoked with
```
protoc --plugin=protoc-gen-schema=./protoc-gen-schema.py
```

You can either use Proto2 or Proto3 files.
However, only a very limited set of Protobuf is supported!
 - only a limited number of types is supported and we make strong assumptions about the types.
 - Enums are not supported
 - `oneof` is not supported
 - default values are not supported
 - extensions are not supported
 - dependencies are not supported

It works quite nice with basic Protobuf stuff.
"""

import sys
import io
from google.protobuf.compiler import plugin_pb2
from google.protobuf.descriptor_pb2 import DescriptorProto, EnumDescriptorProto, FieldDescriptorProto


def map_type(type):
    """
    Maps a field type from Protobuf to an Imlab type.
    This is of course not a perfect mapping.
    On the one hand, not everything is supported in Imlab.
    On the other hand, we assume things like:
     - Floats and doubles is always Numeric<10,4>
     - Strings are always Varchar<30>
    """
    mapping = {
        FieldDescriptorProto.TYPE_DOUBLE: 'Numeric<10,4>',
        FieldDescriptorProto.TYPE_FLOAT: 'Numeric<10,4>',
        FieldDescriptorProto.TYPE_INT64: 'Integer',
        FieldDescriptorProto.TYPE_UINT64: 'Integer',
        FieldDescriptorProto.TYPE_INT32: 'Integer',
        FieldDescriptorProto.TYPE_FIXED64: 'Integer',
        FieldDescriptorProto.TYPE_FIXED32: 'Integer',
        FieldDescriptorProto.TYPE_BOOL: 'unsupported',
        FieldDescriptorProto.TYPE_STRING: 'Varchar<30>',
        FieldDescriptorProto.TYPE_GROUP: '"GROUP" is invalid',
        FieldDescriptorProto.TYPE_MESSAGE: '"MESSAGE" is invalid',
        FieldDescriptorProto.TYPE_BYTES: 'unsupported',
        FieldDescriptorProto.TYPE_UINT32: 'Integer',
        FieldDescriptorProto.TYPE_ENUM: '"ENUM" is invalid',
        FieldDescriptorProto.TYPE_SFIXED32: 'Integer',
        FieldDescriptorProto.TYPE_SFIXED64: 'Integer',
        FieldDescriptorProto.TYPE_SINT32: 'Integer',
        FieldDescriptorProto.TYPE_SINT64: 'Integer',
    }
    return mapping.get(type, 'invalid type')

def generate_header(filedescriptorproto):
    yield '// ---------------------------------------------------------------------------\n'
    yield '// This file is auto-generated.\n'
    yield '// Do not edit this file directly.\n'
    yield '// ---------------------------------------------------------------------------\n'
    yield '#ifndef INCLUDE_IMLAB_SCHEMA_H_\n'
    yield '#define INCLUDE_IMLAB_SCHEMA_H_\n'
    yield '// ---------------------------------------------------------------------------\n'
    yield '#include "imlab/infra/dremel.h"\n'
    yield '#include <vector>\n'
    yield '#include <optional>\n'
    yield '// ---------------------------------------------------------------------------\n'
    yield 'namespace imlab {\n'
    yield 'namespace schema {\n'
    yield '// ---------------------------------------------------------------------------\n'
    yield '\n'

    # Traverse a nested message and create a according type definition.
    def _traverse_type(descriptorproto, ident):
        for nested in descriptorproto.nested_type:
            # we have a nested field (e.g. group or another message)
            yield ident + 'struct ' + nested.name + ' {\n'
            for line in _traverse_type(nested, ident + '    '):
                yield line
            yield ident + '}\n'
        for field in descriptorproto.field:
            if field.type != FieldDescriptorProto.TYPE_GROUP and field.type != FieldDescriptorProto.TYPE_MESSAGE and field.type != FieldDescriptorProto.TYPE_ENUM:
                type_name = map_type(field.type)
            else:
                type_name = field.type_name.split('.')[-1]

            if field.label == FieldDescriptorProto.LABEL_REPEATED:
                yield ident + 'std::vector<' + type_name + '> ' + field.json_name + ';\n'
            if field.label == FieldDescriptorProto.LABEL_OPTIONAL:
                yield ident + 'std::optional<' + type_name + '> ' + field.json_name + ';\n'
            if field.label == FieldDescriptorProto.LABEL_REQUIRED:
                yield ident + type_name + ' ' + field.json_name + ';\n'

    # Traverse a nested message and create columns with a fully qualified name.
    def _traverse_columns(path, descriptorproto):
        for field in descriptorproto.field:
            if field.type != FieldDescriptorProto.TYPE_GROUP and field.type != FieldDescriptorProto.TYPE_MESSAGE and field.type != FieldDescriptorProto.TYPE_ENUM:
                # we have a normal field
                path = path + [field.name]
                yield '    ' + 'DremelColumn<' + map_type(field.type) + '> ' + '_'.join(path) + ' {"' + '.'.join(path) + '"};\n'
        for nested in descriptorproto.nested_type:
            # we have a nested field (e.g. group or another message)
            for line in _traverse_columns(path + [nested.name], nested):
                yield line

    for message in filedescriptorproto.message_type:
        yield 'struct ' + message.name + 'Type {\n'
        for line in _traverse_type(message, '    '):
            yield line
        yield '}\n'
        yield '\n'
        yield 'class ' + message.name + 'Table : public TableBase<' + message.name + 'Type> {\n'
        for line in _traverse_columns([], message):
            yield line
        yield '}\n'


    yield '\n'
    yield '// ---------------------------------------------------------------------------\n'
    yield '}  // namespace schema\n'
    yield '}  // namespace imlab\n'
    yield '// ---------------------------------------------------------------------------\n'
    yield '#endif  // INCLUDE_IMLAB_SCHEMA_H_\n'
    yield '// ---------------------------------------------------------------------------\n'


def generate_source(filedescriptorproto):
    yield '// ---------------------------------------------------------------------------\n'
    yield '// This file is auto-generated.\n'
    yield '// Do not edit this file directly.\n'
    yield '// ---------------------------------------------------------------------------\n'
    yield '\n'
    yield '#include "imlab/schema.h"\n'
    yield '\n'
    yield 'namespace imlab {\n'
    yield 'namespace schema {\n'

    yield '}  // namespace schema\n'
    yield '}  // namespace imlab\n'


def generate_code(request, response):
    for fdesc in request.proto_file:
        if len(fdesc.dependency) > 0:
            sys.stderr.write('Dependencies in .proto file are not supported.')
        if len(fdesc.enum_type) > 0:
            sys.stderr.write('Enums are not supported.')
        if len(fdesc.service) > 0:
            sys.stderr.write('Services are not supported.')
        if len(fdesc.extension) > 0:
            sys.stderr.write('Extensions are not supported.')

        headerdata = ''.join(generate_header(fdesc))
        sourcedata = ''.join(generate_source(fdesc))

        f = response.file.add()
        f.name = 'schema.h'
        f.content = headerdata

        f = response.file.add()
        f.name = 'schema.cc'
        f.content = sourcedata


if __name__ == '__main__':
    # Read request message from stdin
    data = io.open(sys.stdin.fileno(), 'rb').read()

    # Parse request
    request = plugin_pb2.CodeGeneratorRequest.FromString(data)

    # Create response
    response = plugin_pb2.CodeGeneratorResponse()

    # Generate code
    generate_code(request, response)

    # Write to stdout
    io.open(sys.stdout.fileno(), 'wb').write(response.SerializeToString())
