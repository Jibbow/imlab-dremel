#!/usr/bin/env python3

"""
This little Python script serves as a plugin for protoc.
You need to install the "protobuf" Python package.

Will be invoked with
```
protoc --plugin=protoc-gen-schema=./protoc-gen-schema.py ...
```

You can either use Proto2 or Proto3 files.
However, only a very limited set of Protobuf is supported!
 - only a limited number of types is supported and we make strong assumptions about the types.
 - Enums are not supported
 - `oneof` is not supported
 - default values are not supported
 - extensions are not supported
 - dependencies are not supported

It works quite nice with basic Protobuf stuff.
"""

import sys
import io
import os
from google.protobuf.compiler import plugin_pb2
from google.protobuf.descriptor_pb2 import FieldDescriptorProto


def map_type(proto_type, schemac_type=False):
    """
    Maps a field type from Protobuf to an Imlab type.
    This is of course not a perfect mapping.
    On the one hand, not everything is supported in Imlab.
    On the other hand, we assume things like:
     - Floats and doubles is always Numeric<10,4>
     - Strings are always Varchar<30>
    """
    mapping = {
        FieldDescriptorProto.TYPE_DOUBLE: ['Numeric<10,4>', 'schemac::Type::Numeric(10, 4)'],
        FieldDescriptorProto.TYPE_FLOAT: ['Numeric<10,4>', 'schemac::Type::Numeric(10, 4)'],
        FieldDescriptorProto.TYPE_INT64: ['Integer', 'schemac::Type::Integer()'],
        FieldDescriptorProto.TYPE_UINT64: ['Integer', 'schemac::Type::Integer()'],
        FieldDescriptorProto.TYPE_INT32: ['Integer', 'schemac::Type::Integer()'],
        FieldDescriptorProto.TYPE_FIXED64: ['Integer', 'schemac::Type::Integer()'],
        FieldDescriptorProto.TYPE_FIXED32: ['Integer', 'schemac::Type::Integer()'],
        FieldDescriptorProto.TYPE_BOOL: [],
        FieldDescriptorProto.TYPE_STRING: ['Varchar<30>', 'schemac::Type::Varchar(30)'],
        FieldDescriptorProto.TYPE_GROUP: [],
        FieldDescriptorProto.TYPE_MESSAGE: [],
        FieldDescriptorProto.TYPE_BYTES: [],
        FieldDescriptorProto.TYPE_UINT32: ['Integer', 'schemac::Type::Integer()'],
        FieldDescriptorProto.TYPE_ENUM: [],
        FieldDescriptorProto.TYPE_SFIXED32: ['Integer', 'schemac::Type::Integer()'],
        FieldDescriptorProto.TYPE_SFIXED64: ['Integer', 'schemac::Type::Integer()'],
        FieldDescriptorProto.TYPE_SINT32: ['Integer', 'schemac::Type::Integer()'],
        FieldDescriptorProto.TYPE_SINT64: ['Integer', 'schemac::Type::Integer()'],
    }
    m = mapping.get(proto_type, 'invalid type')
    if schemac_type:
        return m[1]
    else:
        return m[0]


def flatten_fields(message, includeInner=False):
    """
    Traverses a Protobuf message and flattens all fields.
    Yields a path consisting of all Protobuf descriptors in an array.
    """
    def _flatten_fields(path, descriptorproto):
        for field in descriptorproto.field:
            if field.type != FieldDescriptorProto.TYPE_GROUP and field.type != FieldDescriptorProto.TYPE_MESSAGE and field.type != FieldDescriptorProto.TYPE_ENUM:
                # We have a normal field.
                yield path + [field]
            else:
                # We have a nested field (e.g. group or another message).
                # There should be an equally named item in 'nested_type' (but lowercase).
                # The FieldDescriptorProto will go into the path and the DescriptorProto from nested_type will be
                # used to further dissect the message.
                # Why do we need to do this?
                # Because nested_types also count as fields and all the info we need is in the FieldDescriptor.
                # However, Descriptors define the hierarchy of fields in a message and a Field has no info about it.
                # And sadly there is no direct mapping between Descriptors and Fields :(
                nested = next(x for x in descriptorproto.nested_type if x.name.lower() == field.name.lower())

                # Not exactly sure why, but Protobuf makes names of Fields that are in nested_type lowercase.
                # But this is only the case for these FieldDescriptors.
                # Leave-FieldDescriptors contain their original name from the file.
                # Also the Descriptors of nested_type contain the original name from the file.
                # Because we only want the original names from the schema file, we need to set it to the correct value.
                field.name = nested.name

                if includeInner:
                    yield path + [field]

                for line in _flatten_fields(path + [field], nested):
                    yield line
    return _flatten_fields([], message)


def generate_header(filedescriptorproto):
    yield '// ---------------------------------------------------------------------------\n'
    yield '// This file is auto-generated.\n'
    yield '// Do not edit this file directly.\n'
    yield '// ---------------------------------------------------------------------------\n'
    yield '#ifndef INCLUDE_IMLAB_SCHEMA_H_\n'
    yield '#define INCLUDE_IMLAB_SCHEMA_H_\n'
    yield '// ---------------------------------------------------------------------------\n'
    yield '#include <optional>\n'
    yield '#include <vector>\n'
    yield '#include "./schema.pb.h"\n'
    yield '#include "imlab/dremel/storage.h"\n'
    yield '#include "imlab/dremel/field_writer.h"\n'
    yield '#include "imlab/infra/types.h"\n'
    yield '#include "imlab/algebra/iu.h"\n'
    yield '#include <google/protobuf/descriptor.h>\n'
    yield '// ---------------------------------------------------------------------------\n'
    yield 'namespace imlab {\n'
    yield 'namespace schema {\n'
    yield '// ---------------------------------------------------------------------------\n'
    yield 'using namespace dremel;\n'
    yield '\n'

    for message in filedescriptorproto.message_type:
        yield 'class ' + message.name + 'Table : public TableBase {\n'
        yield ' public:\n'
        yield '    /// Insert a new record into the table.\n'
        yield '    uint64_t insert(' + message.name + '& record);\n'
        yield '    /// Gets one record from the table.\n'
        yield '    ' + message.name + ' get(uint64_t tid, const std::vector<const FieldDescriptor*>& fields) { return get_range(tid, tid, fields)[0]; }\n'
        yield '    /// Gets a range of record from the table.\n'
        yield '    std::vector<' + message.name + '> get_range(uint64_t from_tid, uint64_t to_tid, const std::vector<const FieldDescriptor*>& fields);\n'
        yield '    /// Get the corresponding FieldWriter-tree for this table.\n'
        yield '    FieldWriter* get_record_writer() override { return &Root_Writer; }\n'
        yield '    /// Get a reference to the IUs in this table.\n'
        yield '    static std::vector<const IU*> get_ius();\n'
        yield '\n'
        yield ' protected:\n'
        for fields in flatten_fields(message):
            column_name = '_'.join([f.name for f in fields])
            containing_type = message.name + ('_' + column_name.rsplit('_', 1)[0] if len(fields) > 1 else '')
            field_descriptor = containing_type + '::descriptor()->FindFieldByName("' + fields[len(fields) - 1].name + '")'
            yield '    ' + 'DremelColumn<' + map_type(fields[-1].type) + '> ' + column_name + ' { ' + field_descriptor + ' };\n'
            yield '    ' + 'std::vector<uint64_t> ' + column_name + '_Record_TIDs;'
            yield '  // Maps the beginning of a record to a TID in the column.\n'
            yield '\n'

        complex_field_writers = {}
        yield '    // A tree-like structure of FieldWriters\n'
        for fields in flatten_fields(message, True):
            column_name = '_'.join([f.name for f in fields])
            if fields[-1].type == FieldDescriptorProto.TYPE_MESSAGE or fields[-1].type == FieldDescriptorProto.TYPE_GROUP:
                previous_children = complex_field_writers.get(column_name, {}).get('children', [])
                complex_field_writers[column_name] = {
                    'children': previous_children
                }
            else:
                containing_type = message.name + ('_' + column_name.rsplit('_', 1)[0] if len(fields) > 1 else '')
                field_descriptor = containing_type + '::descriptor()->FindFieldByName("' + fields[len(fields) - 1].name + '")'
                yield '    AtomicFieldWriter<' + map_type(fields[-1].type) + '> ' + column_name + '_Writer { ' + field_descriptor + ', &' + column_name + ' };\n'

            # Now we need to update the tree structure of FieldWriters and put the current FieldWriter as a child under its parent
            if len(fields) >= 2:
                # A regular writer with a ComplexFieldWriter as a parent
                parent_name = column_name.rsplit('_', 1)[0]
            else:
                # We have a top level writer here directly under the document writer
                parent_name = 'Root'
            # Now update the tree
            previous_children = complex_field_writers.get(parent_name, {}).get('children', [])
            complex_field_writers[parent_name] = {
                'children': previous_children + ['&' + column_name + '_Writer']
            }
        # Print all flattened ComplexFieldWriters
        for parent in complex_field_writers:
            if parent == 'Root':
                field_descriptor = 'nullptr'
            else:
                containing_type = message.name + ('_' + parent.rsplit('_', 1)[0] if parent.count('_') > 0 else '')
                field = parent.rsplit('_', 1)[1] if parent.count('_') > 0 else parent
                field_descriptor = containing_type + '::descriptor()->FindFieldByName("' + field + '")'
            yield '    ComplexFieldWriter ' + parent + '_Writer { ' + field_descriptor + ', { ' + ', '.join(complex_field_writers[parent]['children']) + ' } };\n'

        yield '\n'
        yield '    static const std::vector<IU> IUs;\n'
        yield '};\n'

    yield '\n'
    yield '// ---------------------------------------------------------------------------\n'
    yield '}  // namespace schema\n'
    yield '}  // namespace imlab\n'
    yield '// ---------------------------------------------------------------------------\n'
    yield '#endif  // INCLUDE_IMLAB_SCHEMA_H_\n'
    yield '// ---------------------------------------------------------------------------\n'


def generate_source(filedescriptorproto):
    yield '// ---------------------------------------------------------------------------\n'
    yield '// This file is auto-generated.\n'
    yield '// Do not edit this file directly.\n'
    yield '// ---------------------------------------------------------------------------\n'
    yield '#include "./schema.h"\n'
    yield '#include "imlab/dremel/shredding.h"\n'
    yield '#include "imlab/dremel/assembling.h"\n'
    yield '#include "imlab/dremel/record_fsm.h"\n'
    yield '// ---------------------------------------------------------------------------\n'
    yield 'namespace imlab {\n'
    yield 'namespace schema {\n'
    yield '// ---------------------------------------------------------------------------\n'
    yield '\n'

    for message in filedescriptorproto.message_type:
        yield 'const std::vector<IU> ' + message.name + 'Table::IUs = {\n'
        for fields in flatten_fields(message):
            yield '    IU("' + message.name + '", "' + '.'.join([f.name for f in fields]) + '", ' + map_type(fields[-1].type, True) + '),\n'
        yield '};\n'
        yield '\n'

        yield 'std::vector<const IU*> ' + message.name + 'Table::get_ius() {\n'
        yield '    std::vector<const IU*> refs {};\n'
        yield '    refs.reserve(IUs.size());\n'
        yield '    for (auto& iu : IUs) {\n'
        yield '        refs.push_back(&iu);\n'
        yield '    }\n'
        yield '    return refs;\n'
        yield '}\n'
        yield '\n'

        yield 'uint64_t ' + message.name + 'Table::insert(' + message.name + '& record) {\n'
        yield '    // Before we insert records with DissectRecord, we need to remember the last indices in each column.\n'
        yield '    // They will be the starting points of the fields of the dissected record.\n'
        for fields in flatten_fields(message):
            column_name = '_'.join([f.name for f in fields])
            yield '    ' + column_name + '_Record_TIDs.push_back(' + column_name + '.size());\n'
        yield '\n'
        yield '    Shredder::DissectRecord(dynamic_cast<TableBase&>(*this), record);\n'
        yield '\n'
        yield '    // Now the table contains one more record\n'
        yield '    return size++;\n'
        yield '}\n'
        yield '\n'

        yield 'std::vector<' + message.name + '> ' + message.name + 'Table::get_range(uint64_t from_tid, uint64_t to_tid, const std::vector<const FieldDescriptor*>& fields) {\n'
        yield '    assert(from_tid >= 0 && from_tid <= to_tid && to_tid < size());\n'
        yield '    RecordFSM fsm {fields};\n'
        yield '    // TODO get readers and initialize with TID\n'
        for fields in flatten_fields(message):
            column_name = '_'.join([f.name for f in fields])
            yield '    uint64_t ' + column_name + '_index = ' + column_name + '_Record_TIDs[from_tid];\n'
        yield '\n'
        yield '    std::vector<' + message.name + '> records {};\n'
        yield '    for (unsigned i = from_tid; i < to_tid; i++) {\n'
        yield '        records.push_back(Assembler<' + message.name + '>::AssembleRecord(fsm, readers));\n'
        yield '    }\n'
        yield '    return records;\n'
        yield '}\n'

    yield '\n'
    yield '// ---------------------------------------------------------------------------\n'
    yield '}  // namespace schema\n'
    yield '}  // namespace imlab\n'
    yield '// ---------------------------------------------------------------------------\n'


def generate_code(request, response):
    for fdesc in request.proto_file:
        if len(fdesc.dependency) > 0:
            sys.stderr.write('Dependencies in .proto file are not supported.')
        if len(fdesc.enum_type) > 0:
            sys.stderr.write('Enums are not supported.')
        if len(fdesc.service) > 0:
            sys.stderr.write('Services are not supported.')
        if len(fdesc.extension) > 0:
            sys.stderr.write('Extensions are not supported.')

        headerdata = ''.join(generate_header(fdesc))
        sourcedata = ''.join(generate_source(fdesc))

        f = response.file.add()
        f.name = os.path.splitext(fdesc.name)[0] + '.h'
        f.content = headerdata

        f = response.file.add()
        f.name = os.path.splitext(fdesc.name)[0] + '.cc'
        f.content = sourcedata


if __name__ == '__main__':
    # Read request message from stdin
    data = io.open(sys.stdin.fileno(), 'rb').read()

    # Parse request
    request = plugin_pb2.CodeGeneratorRequest.FromString(data)

    # Create response
    response = plugin_pb2.CodeGeneratorResponse()

    # Generate code
    generate_code(request, response)

    # Write to stdout
    io.open(sys.stdout.fileno(), 'wb').write(response.SerializeToString())
